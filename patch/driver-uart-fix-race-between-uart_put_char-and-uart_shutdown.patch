uart: fix race between uart_put_char() and uart_shutdown()

From: Guohan Lu <gulv@microsoft.com>

backing port a5ba1d95e46ecaea638ddd7cd144107c783acb5d 

commit a5ba1d95e46ecaea638ddd7cd144107c783acb5d
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Fri Jul 6 10:24:57 2018 -0600

    uart: fix race between uart_put_char() and uart_shutdown()
    
    We have reports of the following crash:
    
        PID: 7 TASK: ffff88085c6d61c0 CPU: 1 COMMAND: "kworker/u25:0"
        #0 [ffff88085c6db710] machine_kexec at ffffffff81046239
        #1 [ffff88085c6db760] crash_kexec at ffffffff810fc248
        #2 [ffff88085c6db830] oops_end at ffffffff81008ae7
        #3 [ffff88085c6db860] no_context at ffffffff81050b8f
        #4 [ffff88085c6db8b0] __bad_area_nosemaphore at ffffffff81050d75
        #5 [ffff88085c6db900] bad_area_nosemaphore at ffffffff81050e83
        #6 [ffff88085c6db910] __do_page_fault at ffffffff8105132e
        #7 [ffff88085c6db9b0] do_page_fault at ffffffff8105152c
        #8 [ffff88085c6db9c0] page_fault at ffffffff81a3f122
        [exception RIP: uart_put_char+149]
        RIP: ffffffff814b67b5 RSP: ffff88085c6dba78 RFLAGS: 00010006
        RAX: 0000000000000292 RBX: ffffffff827c5120 RCX: 0000000000000081
        RDX: 0000000000000000 RSI: 000000000000005f RDI: ffffffff827c5120
        RBP: ffff88085c6dba98 R8: 000000000000012c R9: ffffffff822ea320
        R10: ffff88085fe4db04 R11: 0000000000000001 R12: ffff881059f9c000
        R13: 0000000000000001 R14: 000000000000005f R15: 0000000000000fba
        ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018
        #9 [ffff88085c6dbaa0] tty_put_char at ffffffff81497544
        #10 [ffff88085c6dbac0] do_output_char at ffffffff8149c91c
        #11 [ffff88085c6dbae0] __process_echoes at ffffffff8149cb8b
        #12 [ffff88085c6dbb30] commit_echoes at ffffffff8149cdc2
        #13 [ffff88085c6dbb60] n_tty_receive_buf_fast at ffffffff8149e49b
        #14 [ffff88085c6dbbc0] __receive_buf at ffffffff8149ef5a
        #15 [ffff88085c6dbc20] n_tty_receive_buf_common at ffffffff8149f016
        #16 [ffff88085c6dbca0] n_tty_receive_buf2 at ffffffff8149f194
        #17 [ffff88085c6dbcb0] flush_to_ldisc at ffffffff814a238a
        #18 [ffff88085c6dbd50] process_one_work at ffffffff81090be2
        #19 [ffff88085c6dbe20] worker_thread at ffffffff81091b4d
        #20 [ffff88085c6dbeb0] kthread at ffffffff81096384
        #21 [ffff88085c6dbf50] ret_from_fork at ffffffff81a3d69f<U+200B>
    
    for our build, this is crashing at:
    
        circ->buf[circ->head] = c;
    
    Looking in uart_port_startup(), it seems that circ->buf (state->xmit.buf)
    protected by the "per-port mutex", which based on uart_port_check() is
    state->port.mutex. Indeed, the lock acquired in uart_put_char() is
    uport->lock, i.e. not the same lock.
    
    Anyway, since the lock is not acquired, if uart_shutdown() is called, the
    last chunk of that function may release state->xmit.buf before its assigned
    to null, and cause the race above.
    
    To fix it, let's lock uport->lock when allocating/deallocating
    state->xmit.buf in addition to the per-port mutex.
    
    v2: switch to locking uport->lock on allocation/deallocation instead of
        locking the per-port mutex in uart_put_char. Note that since
        uport->lock is a spin lock, we have to switch the allocation to
        GFP_ATOMIC.
    v3: move the allocation outside the lock, so we can switch back to
        GFP_KERNEL
    
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/tty/serial/serial_core.c |   23 ++++++++++++++++-------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index b51b912..f9db242 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -134,6 +134,7 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 	struct uart_port *uport = state->uart_port;
 	struct tty_port *port = &state->port;
 	unsigned long page;
+	unsigned long flags = 0;
 	int retval = 0;
 
 	if (uport->type == PORT_UNKNOWN)
@@ -148,15 +149,18 @@ static int uart_port_startup(struct tty_struct *tty, struct uart_state *state,
 	 * Initialise and allocate the transmit and temporary
 	 * buffer.
 	 */
-	if (!state->xmit.buf) {
-		/* This is protected by the per port mutex */
-		page = get_zeroed_page(GFP_KERNEL);
-		if (!page)
-			return -ENOMEM;
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
 
+	spin_lock_irqsave(&uport->lock, flags);
+	if (!state->xmit.buf) {
 		state->xmit.buf = (unsigned char *) page;
 		uart_circ_clear(&state->xmit);
+	} else {
+		free_page(page);
 	}
+	spin_unlock_irqrestore(&uport->lock, flags);
 
 	retval = uport->ops->startup(uport);
 	if (retval == 0) {
@@ -235,6 +239,7 @@ static void uart_shutdown(struct tty_struct *tty, struct uart_state *state)
 {
 	struct uart_port *uport = state->uart_port;
 	struct tty_port *port = &state->port;
+	unsigned long flags = 0;
 
 	/*
 	 * Set the TTY IO error marker
@@ -265,10 +270,12 @@ static void uart_shutdown(struct tty_struct *tty, struct uart_state *state)
 	/*
 	 * Free the transmit buffer page.
 	 */
+	spin_lock_irqsave(&uport->lock, flags);
 	if (state->xmit.buf) {
 		free_page((unsigned long)state->xmit.buf);
 		state->xmit.buf = NULL;
 	}
+	spin_unlock_irqrestore(&uport->lock, flags);
 }
 
 /**
@@ -476,10 +483,12 @@ static inline int __uart_put_char(struct uart_port *port,
 	unsigned long flags;
 	int ret = 0;
 
-	if (!circ->buf)
+	spin_lock_irqsave(&port->lock, flags);
+	if (!circ->buf) {
+		spin_unlock_irqrestore(&port->lock, flags);
 		return 0;
+	}
 
-	spin_lock_irqsave(&port->lock, flags);
 	if (uart_circ_chars_free(circ) != 0) {
 		circ->buf[circ->head] = c;
 		circ->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);
